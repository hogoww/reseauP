//Misse Chanabier Pierre.
//salle 6.05 machine 1.

#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
#include <netinet/ip.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>

#define SIZE_BUFF 4096

static int receiving=0;
int sockListen;
int descClient;
FILE* fileToSend;  
char* buffer;



void sigINT_handler(int signo){

  if(signo == SIGINT){
    if(receiving){//fermeture dans le fils si il est en train de travailler
      printf("\nkill me when i'm working ain't nice!\n");
      printf("closing though\n");
      close(descClient);
      fclose(fileToSend);
    }//Et fermeture du reste sinon (père + fils)
    else{
      printf("\nClosing, have a nice day :)\n");
    }
    close(sockListen);
    free(buffer);
    exit(EXIT_SUCCESS);
  }
}

int main(int argc,char** argv){
  if(argc!=2){//Verification du nombre d'arguments
    fprintf(stderr,"usage : ./main port\n");
    exit(EXIT_FAILURE);
  }

 
  if(signal(SIGINT, sigINT_handler) == SIG_ERR){//Pour une fermeture propre du serveur.
    fprintf(stderr,"Pas réussi à attribuer au signal INT sa trap\n");
    exit(EXIT_FAILURE);
  }

  int check=chdir("emission");//Pour se placer directement dans le repertoire où les fichiers sont stockés.
  if(check==-1){
    fprintf(stderr,"problème chdir : %s.\n",strerror(errno));
    exit(EXIT_FAILURE);
  }

  sockListen=socket(PF_INET,SOCK_STREAM,0);//création de la socket

  struct sockaddr_in addr;//et remplissage
  memset(&addr,0,sizeof(addr));
  addr.sin_family=AF_INET;
  addr.sin_addr.s_addr=INADDR_ANY;
  addr.sin_port=htons(atoi(argv[1]));
  
  
  int checkBind=bind(sockListen,(struct sockaddr*)&addr,sizeof(struct sockaddr));//binding de la socket.
  if(-1==checkBind){
    fprintf(stderr,"problème bind : %s.\n",strerror(errno));
    exit(EXIT_FAILURE);
  }
  
  if(-1==listen(sockListen,1)){//pour mettre la socket en passif.
    fprintf(stderr,"problème listen : %s.\n",strerror(errno));
    exit(EXIT_FAILURE);
  }
  

  while(1){//On commence la boucle infinie de reception, qui ne se termineras Proprement que sur un sigINT (ctrl + c)
    
    
    printf("waiting for a new client\n");
    descClient=accept(sockListen,NULL,NULL);//acceptation du nouveau client (ou attente de celui ci, vu que accept est bloquant).
    if(-1==descClient){
     fprintf(stderr,"problème accept : %s.\n",strerror(errno));
      exit(1);
    }

    int c=fork();//Pour serveur concurent
    if(c==-1){
      fprintf(stderr,"problème fork : %s.\n",strerror(errno));
      exit(EXIT_FAILURE);
    }
    else{
      if(c!=0){//Père
	close(descClient);//Il ne s'occupe juste pas du client, et recommence à attendre pour le suivant
      }
      else{//Fils Vas envoyer le fichier (si il existe) au client.
	close(sockListen);

	printf("sending a file\n");

	buffer=malloc(sizeof(char)*SIZE_BUFF);//Préparation du buffer d'envois
	memset(buffer,0,SIZE_BUFF);

	ssize_t res=recv(descClient,buffer,SIZE_BUFF,0);//Reception du nom
	if(-1==res){
	  fprintf(stderr,"problème recv fileName : %s.\n",strerror(errno));
	  free(buffer);
	  close(descClient);
	  exit(EXIT_FAILURE);
	}

	int j=0;
	while(buffer[j]!='\0'){//calcul de la longueur du nom
	  j++;
	}
    
	char* fileName=malloc(sizeof(char)*j);
    
	ssize_t i=0;
	while(buffer[i]!='\0'){
	  fileName[i]=buffer[i];
	  i++;
	}
    
    
	printf("\n%s\n",fileName);//Notification sur la sortie standards du nom du fichier à envoyer
      
	fileToSend=fopen(fileName,"r");//Ouverture du fichier.
	if(fileToSend==NULL){//Si le fichier n'existe pas, le fils s'arrète.
	  fprintf(stderr,"file failed to open : %s.\n",strerror(errno));
	  close(descClient);
	  free(buffer);
	  remove(fileName);//On retire le fichier vide nouvellement créé.
	  exit(EXIT_FAILURE);
	}
	    
	while(1){//sinon il envoit le fichier.
	  i=0;
	  while(i<SIZE_BUFF){//On remplis le buffer.
	    c=fgetc(fileToSend);
	    buffer[i]=c;
	    if(feof(fileToSend)){//Jusqu'à rencontrer la fin du fichier.
	      break;
	    }
	    i++;
	  }


	  ssize_t res=send(descClient,buffer,i,0);//Et on l'envois, jusqu'à la taille maximale, ou la fin du fichier
	  if(-1==res){
	    fprintf(stderr,"problème send : %s.\n",strerror(errno));
	    close(descClient);
	    free(buffer);
	    fclose(fileToSend);
	    exit(EXIT_FAILURE);
	  }

	  if(feof(fileToSend)){//fin du fichier atteinte, on a finis.

	    res=send(descClient,buffer,0,0);
	    if(-1==res){
	      fprintf(stderr,"problème send : %s.\n",strerror(errno));
	      close(descClient);
	      free(buffer);
	      fclose(fileToSend);
	      exit(EXIT_FAILURE);
	    }

	    break;
	  }
	}
	printf("done sending a file\n");
	close(descClient);
	exit(EXIT_SUCCESS);
      }
    }
  }

  //Personne n'arrive ici:
  //Le père se termine par un SIGINT
  //Le fils s'arrète après avoir envoyé son fichier.
  return 1;
}
